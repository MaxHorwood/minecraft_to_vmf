<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0;  }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <input type="file" id="myFile" multiple size="50" onchange="myFunction()">
        <input type="button" value="UP" id="myButton" onclick="yOffUpdate(1, 0, 0)">
        <input type="button" value="DWN" id="myButton" onclick="yOffUpdate(-1, 0, 0)">
        <input type="button" value="<" id="myButton" onclick="yOffUpdate(0, 0, -1)">
        <input type="button" value=">" id="myButton" onclick="yOffUpdate(0, 0, 1)">
        <input type="button" value="▲" id="myButton" onclick="yOffUpdate(0, -1, 0)">
        <input type="button" value="▼" id="myButton" onclick="yOffUpdate(0, 1, 0)">
        <canvas id="myCanvas"></canvas>
        <canvas id="myCanvas1"></canvas>
        <script src="https://threejs.org/build/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        
        <!-- Scripts for handling mincraft data -->

        <script src="js/util.js"></script>
        <script src="js/inflate.js"></script>
        <script src="js/deflate.js"></script>
        <script src="js/Chunk.js"></script>
        <script src="js/DataReader.js"></script>
        <script src="js/Region.js"></script>
        

        <script src="js/nbt.js"></script>
        <script>

            /*
                Props: http://minecraft-ids.grahamedgecombe.com/api Provides a JSON list of all minecraft ids etc... (and related names to the correct images)
                (http://minecraft-ids.grahamedgecombe.com/items.json)
            */

            var block_mat_data = [
                [],
                [loadMat('stone.png'), 'ardite', 'something'], 
                [loadMat('grass_side.png')], 
                [loadMat('dirt.png'), 'second', 'thrid'],
                [loadMat('cobblestone.png')]];

            function loadMat(loc) {
                var mat = new THREE.TextureLoader().load('blocks/'+loc);
			    mat.magFilter = THREE.NearestFilter;
			    mat.minFilter = THREE.LinearMipMapLinearFilter;

                return mat;
            }

            var yOff = 44;
            var xOff = 1;
            var zOff = 1;
            var region_data = null;
            
            var section_g = 0;

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 90, window.innerWidth/window.innerHeight, 3, 1000 );
            var controls = new THREE.OrbitControls( camera );
			
			var camera1 = new THREE.OrthographicCamera(-15, 15, 15, -15, 0.1, 1000);
            var cameraHelper = new THREE.CameraHelper(camera1);
			
			
            // Creates canvas that displays the content
			var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas')});
            var renderer1 = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas1')});
            renderer.setClearColor(0x004440);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer1.setClearColor(0x004440);
            renderer1.setSize(window.innerHeight, window.innerHeight);
            var light = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(light);

            var light1 = new THREE.PointLight(0xffffff, 0.5);
            scene.add(light1);
            scene.add(cameraHelper);
            var offestX = 10;
            var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
			var mat = new THREE.TextureLoader().load('blocks/grass_side_snowed.png');
			mat.magFilter = THREE.NearestFilter;
			mat.minFilter = THREE.LinearMipMapLinearFilter;
            
            function myFunction(){
                var file = document.getElementById("myFile");
                var actual_file = file.files[0];
				console.log(actual_file);
				region_data = new Region(actual_file);
				region_data.load(function(){
                    console.log();
                    var total_blocks = 0;
                    
                    for (var y = 0; y < 16; y++){
                        for (var x = 0; x < 16; x++){
                            for (var z = 0; z < 16; z++){
                                
                                var pos = y*16*16 + z*16 + x;
                                
                                var section = region_data.chunks[[0,0]].sections[3].Blocks;
                                var block_value = section[pos];

                                var block_x = x;
                                var block_z = z;
                                var block_y = y;
                                if (block_value !== 0){
                                    // Basic optimizations
                                    var above =    (y+1)*16*16 + z*16 + x;
                                    var below =    (y-1)*16*16 + z*16 + x;
                                    // These directions are most probably wrong, don't know if z == front or x == side...
                                    var forward =  y*16*16 + (z+1)*16 + x;
                                    var backword = y*16*16 + (z-1)*16 + x;
                                    var left  =    y*16*16 + z*16 + x+1;
                                    var right =    y*16*16 + z*16 + x-1;
                                    // if its the edge of the chunk we want to render it no matter what (when its not air...)
                                    var isEdge = false;
                                    if (section[above] == undefined || section[below] == undefined){
                                        isEdge = true;
                                    }
                                    if (!isEdge && x == 0 || x == 15 || z == 0 || z == 15){
                                        isEdge = true;
                                    }
                                    
                                    if ( isEdge || section[above] == 0 || section[below] == 0 || section[forward] == 0 || section[right] == 0 || section[backword] == 0 || section[left] == 0) {
                                        var xx;
                                        if (block_mat_data[block_value] != undefined && typeof block_mat_data[block_value][0] == "object") {
                                            xx = new THREE.MeshBasicMaterial( {map: block_mat_data[block_value][0] })
                                        }else{
                                            xx = new THREE.MeshBasicMaterial( { map: mat } );
                                        }
                                        
                                        var object = new THREE.Mesh( geometry, xx );
                                        //var material = new THREE.MeshLambertMaterial( { color: Math.Random()*0xffffff } );
                                        //var cube = new THREE.Mesh( geometry, material );
                                        
                                        object.position.x = x;
                                        object.position.z = z-offestX;
                                        object.position.y = y;
                                        total_blocks++;
                                        scene.add(object);
                                    }
                                }
                            }
                        }
                    }
                    console.log("TOTAL: "+total_blocks);

                });
                
            }

			// updates the visual display (scene) in a given direction...
            function yOffUpdate(yDif, zDif, xDif){
				// This function should handle ALL directions
				// Add another 2 param for x and z
				// Add checking so don't go to low/high.
				// Maybe add a away to load another region file if user navigates outside of the current one?
			
				// Removes all mesh's (Blocks)
				// Probably optimize by only removing the 2 rows/cols that need to be replaced then just translate the other meshs in the correct manner?
                for (let i = scene.children.length - 1; i >= 0; i--) {
                    if(scene.children[i].type === "Mesh")
                        scene.remove(scene.children[i]);
                }
                
                yOff += yDif; // Current offset based on user input
                xOff += xDif;
                zOff += zDif;
                console.log("YOFF:" +yOff + "\nZOFF:"+zOff+"\nXOFF:"+xOff);

                var chunk_x = 0;
                var chunk_z = 0;
                var chunk_y = 0;

                for (var y = 0; y < 16; y++){
                    // The actual y position (from the bottom up)
                    var yy = y + yOff;
                    // Get the section based on the actual y
                    var chunk_y_temp = Math.ceil((yy) / 16);
                    chunk_y = chunk_y_temp - 1;
                    // yy has to be larger than section_g*16 as Math.ceil (-1) produces the correct section value which can be used to get the offset for the correct y position given the new section
                    yy = yy - (chunk_y*16); 
                    yy = yy - 1;
                    for (var z = 0; z < 16; z++){
                        var zz = z + zOff;
                        var chunk_z_temp = Math.ceil(zz / 16);
                        chunk_z = chunk_z_temp - 1;
                        zz = zz - (chunk_z*16);
                        zz = zz - 1;

                        for (var x = 0; x < 16; x++){
                            var xx = x + xOff;
                            var chunk_x_temp = Math.ceil(xx / 16);
                            chunk_x = chunk_x_temp - 1;
                            xx = xx - (chunk_x*16);
                            xx = xx - 1;
                           
                            var pos = yy*16*16 + zz*16 + xx;
                            //console.log("ChunkX: "+chunk_x+"\nChunkZ: "+chunk_z);
                            var section = region_data.chunks[ [chunk_x, chunk_z] ].sections[chunk_y].Blocks;
                            var block_value = section[pos];
							
                            if (block_value !== 0){
                                // Basic optimizations
                                var above =    (yy+1)*16*16 + zz*16 + xx;
                                var below =    (yy-1)*16*16 + zz*16 + xx;
                                // These directions are most probablyy wrong, don't know if z == front or x == side...
                                var forward =  yy*16*16 + (zz+1)*16 + xx;
                                var backword = yy*16*16 + (zz-1)*16 + xx;
                                var left  =    yy*16*16 + zz*16 + xx+1;
                                var right =    yy*16*16 + zz*16 + xx-1;
                                
								
								
								// Check if the block is on the edge of the chunk so there are no leaks when viewing
								// If unoptimised viewing is wanted (ALL BLOCKS RENDERED) then set isEdge = true.
								var isEdge = false;
                                //isEdge = true; // Uncomment for ALL blocks to be drawn
								if (x == 0 || x == 15 || z == 0 || z == 15 || y == 0 || y == 15){
                                    isEdge = true;
                                }
								// This needs to be further improved by checking the the proper section (
								// ie: if we are on y == 15 and yy is 16 (section_g would be +1 for y==15) when we check below yy the position will be invalid as the section is incorrect due to how the chunks are loaded.
								if ( isEdge || section[above] == 0 || section[below] == 0 || section[forward] == 0 || section[right] == 0 || section[backword] == 0 || section[left] == 0) {
                                    var xx;
                                    if (block_mat_data[block_value] != undefined && typeof block_mat_data[block_value][0] == "object") {
                                        xx = new THREE.MeshBasicMaterial( {map: block_mat_data[block_value][0] })
                                    }else{
                                        xx = new THREE.MeshBasicMaterial( { map: mat } );
                                    }
                                        
                                    var object = new THREE.Mesh( geometry, xx );
                                    //var material = new THREE.MeshLambertMaterial( { color: Math.Random()*0xffffff } );
                                    //var cube = new THREE.Mesh( geometry, material );
                                    
                                    object.position.x = x;
                                    object.position.z = z-offestX;
                                    object.position.y = y;

                                    scene.add(object);
                                }
                            }
                        }
                    }
                }

                console.log("Section: " +section_g + " yOff: "+yOff);
            }
			/*var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
            var material = new THREE.MeshLambertMaterial( { color: 0x00ff00 } );
            var cube = new THREE.Mesh( geometry, material );
            cube.position.set(0, 0, -1);
			scene.add( cube );
            
			camera.position.y = 5;
            camera.position.x = 5;
            camera.position.z = 5;*/
			camera.position.set( -10, 10, 10 );
            camera1.position.y = 16; // position it above by one
            camera1.rotation.x = -1.5708; // Rotate in -90deg (Facing down)
			controls.update();
			
			var animate = function () {
				requestAnimationFrame( animate );
                /*delta += 0.01;
                camera.lookAt(camera1.position);
                camera.position.x = Math.sin(delta) * 21;
                camera.position.y = Math.cos(delta) * 21;*/

				controls.update();
                renderer1.render(scene, camera1);
				renderer.render(scene, camera);
                
			};

			animate();
		</script>
	</body>
</html>